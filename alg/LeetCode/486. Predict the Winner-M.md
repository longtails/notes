### 486. 预测赢家-M

label: 博弈，dp

给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

示例 1:

输入: [1, 5, 2]   
输出: False   
解释: 一开始，玩家1可以从1和2中进行选择。   
如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。   
所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。   
因此，玩家1永远不会成为赢家，返回 False。   

示例 2:  

输入: [1, 5, 233, 7]   
输出: True   
解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。   
最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。   

注意:  

1 <= 给定的数组长度 <= 20.   
数组里所有分数都为非负数且不会大于10000000。   
如果最终两个玩家的分数相等，那么玩家1仍为赢家。   



分析：  
1. 之前做过除数博弈，偶数数时先手必胜(1025. 除数博弈-E)；石子游戏，有偶数堆，先手必胜(877. 石子游戏-M)
2. 这道题目跟石子游戏一样，只是换了个说法，多了奇数，所以偶数判断，直接先手胜，奇数需要用dp(相应的石子游戏升级，加入奇数,1140. 石子游戏 II)      
3. dp[i][j]表示在nums{i,j}先手取得的值比后手大的差值，dp[i][j]=max{nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]},表示取nums[i]或nums[j]后相比后手多的差值，最后判断dp[0][size-1]>=0即可  

递推公式,dp[i][j]表示先手的差值，dp[i+1][j]和dp[i][j-1]表示后手的差值
$$
dp[i][j]=max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]) 
$$

```go
package main

import "fmt"

//486. Predict the Winner
/*
执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户
内存消耗 :2.1 MB, 在所有 Go 提交中击败了50.00%的用户
*/
func PredictTheWinner(nums []int) bool {
	size:=len(nums)
	if size%2==0{ return true }
	dp:=make([][]int,size)
	for i:=0;i<size;i++{
		dp[i]=make([]int,size)
		dp[i][i]=nums[i]
	}
	for k:=1;k<size;k++{
		for i:=0;i<size;i++{
			j:=i+k
			if j>=size{ break }
			//0 1
			if nums[i]-dp[i+1][j]>nums[j]-dp[i][j-1]{
				dp[i][j]=nums[i]-dp[i+1][j]
			}else{
				dp[i][j]=nums[j]-dp[i][j-1]
			}
		}
	}
	return dp[0][size-1]>=0
}
func main() {
	tables:=[][]int{
		{1, 5, 2}, //false
		{1, 5, 233, 7}, //true
		{1,2,99}, //true
		{1,1}, //true
		{2,4,55,1}, //true
		{0},//true
		{10,17,11,16,17,9,14,17,18,13,11,4,17,18,15,3,13,10},//true
	}
	for _,v:=range tables{
		fmt.Println(PredictTheWinner(v))
	}
}
```