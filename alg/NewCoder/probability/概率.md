### 概率

概率问题常见类型: 
1. 在笔试面试中常作为客观问题出现（选择题）。
2. 在笔试中往往出现概率、期望的计算。 
3. 往往利用古典概率进行计算（组合数学）。

概率的应用：
1. 利用随机来改进著名算法（快速排序） 
2. 随机数发生器（用给定的随机数发生器构造另一个）

#### 案例一

8支球队，有3个强队，其余都是弱队，随机把他们分成4组比赛，每 组两个队，问两强相遇的概率是多大？   
1. 首先求出8支球队分成4组比赛的方法数：任选一个队伍有7种选择，再选一个队伍有5种，再选有3，再选有1，即7x5x3x1=105种选择方式;  
2. 没有两强相遇的方法数：3个强队和5个弱队配对，剩下组成一对，即C(5,3)xA(3,3)=60；   
3. 求两强不相遇的方法数为：（105-60）/105=3/7

为什么用这个方法求105，不解，有其他方法吗？

e.g.   
有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？

给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数

测试样例：
4   
返回：[3,7]
```cpp
class Championship {
public:
    int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
    		tmp*=i;
    	}
    	for(int i=1;i<=y;i++){
    		tmp/=i;
    	}
    	return tmp;
        }
    int A(int x,int y){
    	int tmp=1;
    	for(int i=(x-y+1);i<=x;i++){
	    	tmp*=i;
    	}
	    return tmp;
    }    
    vector<int> calc(int k) {
        if(k==2){
            vector<int>ret{0,1};
            return ret;
        }
        int all=1;
        for(int i=1;i<2*k;i+=2){
            all*=i;
        }
        int x=all-C(k+1,k-1)*A(k-1,k-1);
        int tmp=1;
        for(int i=2;i<=x;i++) if(x%i==0&&all%i==0)tmp=i;
        vector<int>ret{x/tmp,all/tmp};
        return ret;
    }
};
```

#### 案例二

三只蚂蚁从正三角的三个定点沿着边移动，速度是相同的，问他们碰头的概率是多少？


它们顺序相同时，是一定不会相遇的，有两种；每个蚂蚁有两个方向选择即共8种；所以相遇的概率为(8-2)/8=3/4。

e.g.   
n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？

给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。

测试样例：
3   
返回：[3,4]
```cpp
class Ants {
public:
    vector<int> collision(int n) {
        int x=1;
        for(int i=1;i<n;i++){
            x*=2;
        }
        int y=x-1;
        vector<int>ret{y,x};
        return ret;
    }
};
```

#### 案例三

某地区重男轻女，一个家庭如果生出一个女孩就一直生，直到生出男孩就停止生育，假设一胎只生一个孩子，问时间足够长后，男女比例回事多少？

假设这一地区一共有n个家庭，  
n/2的家庭第一胎就生出男孩，所以只有1个孩子；  
有n/4的家庭先生1女孩，再生1男孩，有2个孩子；  
有n/8的家庭先生2女孩，再生1男孩，有3个孩子；  
...   
所以全部家庭的孩子数：  
n/2+(n/4)\*2+(n/8)\*3+(n.16)\*4...=2\*n;  
每个家庭都会有一个男孩，所以2n的孩子种，男孩数为n，女孩数为2n-n=n,所以比例依然为1:1。  
#### 案例四  

给定一个等概率随机产生1～5的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生1～7的随机函数。  

一种扩充涵盖7的方法   
1. 已经有等概率随机产生1,2,3,4,5的随机函数  
2. 根据步骤1得到的结果减1，将得到f()->0,1,2,3,4  
3. f()x5->0,5,10,15,20  
4. f()x5+f()->0,1,2,3,4,...,24 (两次调用f) 
5. 如果步骤4产生的数大于20,则重复进行步骤4，直到产生的结果在0～20之间
6. 步骤5的结果将等概率的随机产生0～20，所以步骤5的结果%7之后等概率产生0～6  
7. 步骤6的结果+1，将等概率产生1～7  

该方法是扩充一种方便产生%7的方法，原本f长生0,1,2,3,4长度为5，那5xf之后变为0,5,10,15,20其间隔空连续5个数，这正式f可以产生的，所以5Xf+f就可以等概率产生大于7的部分，并且**数据都是连续的等概率的产生大于7的数**，所以mod 7很方便。

注意f+f是不容等概率的产生涵盖7的，比如[0,1,2,3,4],[0,1,2,3,4]->[0,1,2,3,4,5,6,7,8]其中0、1、7、8概率相等，3、5概率相等，2、4概率相等。    
这个题目的本质就是如何找到一个有7个元素的等概率调整。
```cpp
class Random5 {
public:
	static int randomNumber();
};
class Random7 {
public:
    int rand5() {
        return Random5::randomNumber();
    }
    int randomNumber() {
        while(true){
           int r7=5*rand5()+rand5()-5;
           if(r7<=21)return r7%7+1;
        }
        return 1;
    }    
};
```
 

##### 案例五

给定一个以p概率产生0，以1-p概率产生1的随机函数f(),p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用f()实现等概率随机产生0和1的随机函数。  

两次调用结果可能是[00,01,10,11]其中10和01的概率相等，所以这个随机函数可以用连续两次调用f实现：当结果是01时，返回0,结果是10时返回1,当结果时00/11时再次进行调用，直到出现00或者11。

```cpp
class RandomP {
public:
	static int f();
};
class Random01 {
public:
    // 用RandomP::f()实现等概率的01返回
    int random01() {
        while(true){
            int a=RandomP::f();
            int b=RandomP::f();
            if(a==0&&b==1)return 0;
            if(a==1&&b==0)return 1;
        }
        return 0;
    }
};
```


#### 案例六

假设函数f()等概率随机返回一个在[0,1）范围上的浮点数，那么我们知道，在[0,x)区间上的数出现的概率为x(0 < x <= 1)。给定一个大于0的整数k，并且可以使用f()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,x)区间上的数出现的概率为x的k次方。

首先，如何把[0,x)范围上的数，从概率X调整为概率X^2,   
作法：调用两次f(),返回较大的数仍然是[0,x)区间上的话，那么两次调用调用f的返回值都必须落在[0,x)上，否则就会返回大于x的数了，所以概率就为x^2;    
所以本题只用调用K次f(),返回较大的数，即可。

```cpp
$$
p1=\frac{k}{k+1}*\frac{1}{k}=\frac{1}{k+1}
$$
$$
p=1-p1=1-\frac{1}{k+1}=\frac{k}{k+1}
$$
```

#### 案例七

给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。 

方法：
1. 在0,N-1种随机得到一个位置a,和N-1位置交换;
2. 在0,N-2中随机得到一个位置b,和N-2为止交换,所以之前访问的元素就不会出现了;
3. 以此类推，直到打印M个数即可。 

其实是，怎么保证不放回的，抽取概率相等吧。。。

更概率随机的问题很多会用到和最后一个交换的作法。

```cpp
class RandomPrint {
public:
    vector<int> print(vector<int> arr, int N, int M) {
        vector<int>ret;
        for(int i=0;i<M;i++){
            int p = rand() % (N - i);
            ret.push_back(arr[p]);
            int tmp=arr[p];
            arr[p]=arr[N-i-1];
            arr[N-i-1]=tmp;
        }
        return ret;
    }
};
```

#### 案例八

有一个机器按自然数序列的方式吐出球，1号球，2号球，3号球等等。你有一个袋子，袋子里最多只能装下K个球，并且除袋子以外，你没有更多的空间，一个球一旦扔掉，就再也不可拿回。设计一种选择方式，使得当机器吐出第N号球的时候，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。  
举一个更具体的例子，有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10 球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有 10 个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i。也就是随着N的变化，1~N号球被选中的概率动态变化成k/N。请将吐出第N个球时袋子中的球的编号返回。


此题目核心解法是蓄水池抽样算法，过程如下：
1. 处理1～k号球时，直接放进袋子里；  
2. 处理第i号球时，以k/i的概率决定是否将第i号球放进袋子。如果不决定将第i号球放进袋子，直接扔掉第i号球。如果决定将第i号球放进袋子，那么就从袋子里的k个球中随机扔掉一个，然后把第i号球放入袋子。  
3. 处理第i+1号球时，重复步骤1或步骤2。 

证明过程：
假设第i号球被选中并且1<=i<=k,那么在选第k+1号球之前，第i号球留在袋子中的概率是1。在选第k+1号球时，在什么样的情况下第i号球会被淘汰呢？只有决定将第k+1号球放进袋子，同时在袋子中的第i号球被随机选中并决定扔掉，这两个事件同时发生时第i号球才会被淘汰。也就是说第i号球被淘汰的概率为(k/(k+1))*（1/k)等于1/(k+1)，所以第i号球留下来的概率就是1-(1/(k+1))=k/(k+1)，这是1号球到第k+1号球的过程中，第i号球留下来的概率。  
$$
p_{k+1}=\frac{k}{k+1}*\frac{1}{k}=\frac{1}{k+1}
$$
$$
p=1-p_{k+1}=1-\frac{1}{k+1}=\frac{k}{k+1}
$$
在选第k+2号球时，什么样的情况下第i号球会被淘汰呢？只有决定将第k+2号球放进袋子，同时在袋子中的第i号球被随机选中并决定扔掉。这两个事件同时发生时第i号球才会被淘汰。也就是说，第i号球会被淘汰的概率是(k/k+2)*(1/k)=1/(k+2)，那么第i号球留下来的概率就是1-(1/(k+2))=(k+1)/(k+2)，那么从1号球到第k+2号球的过程中，第i号球留在袋子中的概率是k/(k+1)\*(k+1)/(k+2)。
 
$$
p_{k+2}=\frac{k}{k+2}*\frac{1}{k}=\frac{1}{k+2}
$$
$$
p=1-p_{k+2}=1-\frac{1}{k+2}=\frac{k+1}{k+2}
$$
依次类推，在选第N号球时，从1号球到第N号球时的全部过程中，第i号球最终留在袋子中的概率是大家看到的式子。化简之后为k/N。

$$
\frac{k}{k+1}*\frac{k+1}{k+2}*...*\frac{N-1}{N}=\frac{k}{N}
$$


按照同样的方法，假设第i号球被选中并且k< i <= N,那么在选第i号球时，第i号球被选进袋子的概率是k/i。在选第i+1号球时，在什么样的情况下第i号球会被淘汰？只有决定将第i+1号球放进袋子，同时在袋子中的第i号球被随机选中决定扔掉，这两个事件同时发生时第i号球才会被淘汰。那么第i号球会被淘汰的概率是(k/(i+1))*(1/k)等于1/(i+1)。那么第i号球被选中到第i+1号球的过程中，第i号球留在袋子中的概率是(k/i)\*(i/(i+1))。
$$
p_{i}=\frac{k}{i}*\frac{i}{i+1}
$$

和刚才的分析过程同理，每一次处理球的时候，第i号球都会有被淘汰的可能，当然也能算出留下来的概率。当处理完N号球的时候，i号球依然没有淘汰的概率是大家看到的式子,化简后为k/N。所以该方法有效。
$$
p_{i}=\frac{k}{i}*\frac{i}{i+1}*\frac{i+1}{i+2}*...*\frac{N-1}{N}=k/N
$$

```cpp
class Bag {
public:
	vector<int> ret;
    // 每次拿一个球都会调用这个函数，N表示第i次调用
    vector<int> carryBalls(int N, int k) {
        if(N<=k)ret.push_back(N);
        else{
            int i=rand()%N;
            if(i<k)ret[i]=N;
        }
        return ret;
    }
};
```