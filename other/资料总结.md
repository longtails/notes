

Hash表：常见hash函数，直接定址法，除留余数法，数字分析法:   
**直接定址法：** H(key)=a*key+b,计算简单，不会产生冲突，适合关键字连续分布的，否则空位较多，空间浪费   
**除留余数法：** H(key)=key%p，表长m，选择最接近或等于m的质数p,这种方法最简单，最常用，关键是选好p,使得每个关键字通过该函数转换后都能等概率的映射到散列空间上任一地址，从而尽可能减少冲突的可能性   
**数字分析法:** 关键字是r进制数，r个数码在各位上，出现的频率不一定相同，应选择数码分布相对均匀的若干位作为散列地址，这种方法只适合已知的关键字集合。

***处理冲突:****   
1. 拉链法，对相同地址的关键字，则用线性链表存储，这种方法适合经常进行插入和删除的情况  
2. 开发定址法，空闲地址向非同义词开发，H=(H(key)+di)%m,引入di增量序列；但开放地址有个问题，就是不能随便物理删除，需要删除，可以做个删除标记，表示逻辑删除，带来的结果是，整个表很大，但实际上很多空间没有用到，所以需要定期维护散列表。这个增量di的选择有四种常用方法：
   1. 线性探测法，di=1,2,3,...,m-1,即当冲突时，顺序查找下一个单元，直到全表，该方法容易造成数据聚集，降低查找效率
   2. 平方探测法，di=1,-1,2^2,-2^2,3^2,-3^2,...,k^2,-k^2,k<=m/2,m必须是一个可以表示成4k+3的质数，这是一种比较好的处理冲突方法，可以避免数据堆积，缺点是不能探测到Hash表上的所有单元，但至少能探测一半。
   3. 再散列法，di=i*hash2(key),利用第二个散列函数计算该关键字的地址增量，最多经过m-1测探测，会遍历表中所有位置，回到H0位置  


装填因子a=表中记录数n/散列表长度m，表示装满程度，Hash表的查找效率与散列函数，处理冲突的方法和装填因子。hash表的平均查找长度不单独取决于n和m，而是a。

---

B数，红黑树

---
外部排序：

---

网络分层：


ARP协议:
完成ip到mac地址的映射，主机上存放一个IP-MAC地址映射表，ARP表，并通过ARP协议动态维护此表。   
**ARP协议工作在网络层**。工作原理：主机A向本局域网上的某个主机B发送IP数据报时，先查看ARP告诉缓存中是否有主机B的IP地址，若有，则可查出对应的硬件地址，再将MAC地址写入MAC帧，然后通过局域网发出去；若没有，则先通过广播ARP请求分组(MAC帧的目的地址为FF-FF-FF-FF-FF-FF),在获得目标主机的ARP响应分组后，将目标主机的硬件与IP的映射关系写入ARP缓存表中，然后按此硬件地址写入MAC帧，发送出去。   
注意，ARP解决的是一个局域网上的主机或路由器的IP-MAC映射问题，若两个主机不在一个局域网上，则要通过ARP协议找到本局域网上路由器的硬件地址，将分组发送给该路由器，然后有路由器转发到下一个网络。

DHCP动态主机配置协议，使计算机动态加入新的网络，并动态分配IP地址，DHCP是应用层协议，基于UDP。主机启动时，通过广播发现报文，然后DHCP服务分配IP并作响应。   
ICMP:为提高IP数据报文交付成功的机会，ICMP协议来报告差错和异常情况，ICMP实际也是IP分组，只不过ICMMP被作为IP分组的数组字段，ICMP为网络层。

ICMP两个常见应用，PING和Tracerroute：    
PING利用的是ICMP回送请求和回答报文，工作在应用层，它直接使用网络层的ICMP协议，没有使用传输层的TCP/UDP;   
Tracerroute使用ICMP不可达差错报文，发送修改IP报文的最大跳数，工作在网络层。

NAT:解决IPv4地址不够用的问题，路由器上安装NAT软件，通过NAT转换地址将本地地址转换层公网ip，NAT会查看和转换传输层的端口。  
私有IP，不能上公网，因为公网上的路由直接对其私有IP。  

反向代理？

TCP三次握手、四次挥手：

DNS域名解析过程：
层次域名空间，一个ip可以对应多个域名；
域名服务器，C/S模型，有四种不同类型的域名服务器：  
**本地域名服务器**:每个ISP，学校，部门都可以拥有一个自己的本地域名服务器,本机IP配置时其DNS指向本地域名服务器；  
**根域名服务器**:Internet上有十几个根域名服务器，大部分在北美，该服务器是最重要的域名服务器,当本地域名服务器无法解析某个DNS请求时，此DNS会被转发到一个根域名服务器进行查询，根域名服务器管理顶级域名(如.com)。当根域名也没查到，它根据顶级域名信息告诉下属的某个本地域名服务器应当去哪个顶级域名服务器查询。  
**顶级域名服务器**： 负责管理在顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，给出相应回答，若未能解析到，则返回下一级的域名服务器地址。   
**授权域名服务器**：每个主机都必须在授权域名服务器处登记。为了可靠，每个主机最好至少有两个授权域名服务器。许多域名服务器同时充当本地域名服务器和授权域名服务器。授权域名服务器总是能够将其管辖的主机名转换为该主机的IP地址。  

域名->IP：正向解析；IP->域名：反向解析  
解析时，本地DNS客户端向本地域名服务器发送UDP数据请求报文，具体解析过程：   
递归查询： 主机->本地域名服务器-->根域名服务器-->顶级域名服务器-->授权域名服务器-->顶级-->根-->本地->主机  
迭代查询：主机->本地域名<-->根域名；本地<-->顶级；本地<-->授权；本地->主机

理解，其实最高层次的是根域名服务器，然后通过层次管理的方式，依此降级管理；授权域名服务器，就是最低的域名管理的服务器，记录了主机IP对应的完整域名；而本地域名服务器，更像一个记录的缓存表，同样根也缓存了部分域名。

再结合域名的层次划分：在主机缓存中未查到；请求本地域名服务器（主机和本地域名服务器都只是缓存记录，而不是管理着，都需要向管理者请求）；本地缓存中未命中，递归到根域名（根是管理）；根缓存未命中，这时发挥它的管理作用，根据记录的顶级域名服务器地址，根向顶级服务器请求；顶级还未命中，那直接向在顶级服务器中记录的授权服务器(顶级下的子服务器)，最后一定能否在授权服务器中查询到，否则不存在，最后迭代返回。   
迭代的方式，是本地域名服务器分别和根、顶级、授权，依次请求，后续的服务器的IP有前一个服务器提供。这里体会到本地域名服务器的作用，因为一般主机没权限，同时加了一层，能够降低域名管理者的压力。


HTTP/HTTPS:   
1. 长连接、短连接
2. https建立连接过程



---

#### 程序的装入和链接：

一个简单的c程序hello world，从启动，到输出的全过程：

1. 预处理、编译、汇编、链接，生成目标文件，a.out
2. ./a.out 启动启动程序，shell更具文件名和环境变量去读取磁盘中的二进制文件
3. 根据目标文件的ELF文件头，获取一些必须要的信息比如机器位数、程序入口地址，处理执行二进制文件，在终端输出hello world

链接：重定位的问题，需要将外部引入的信息，比如外部函数，这些函数、变量，并没有在目标文件内，在链接时，完成地址的填充；

装载：把程序加载到物理内存中，程序使用虚拟存储机制，需要将虚拟地址转化为物理地址，这里的地址转化由操作系统利用地址转换机构完成,linux逻辑存储上采用页表管理的方式，64位虚拟地址使用48位物理地址，划分为4x9+12,四级页表+页内偏移的方式，
运行时动态重定位获取物理地址，指令代码通过基址+限址的方式，PC指令计数器，执行执行。

运行时库，C运行时库除了给我们提供必要的库函数调用（如memcpy、printf、malloc等）之外，它提供的另一个最重要的功能是为应用程序添加启动函数；C运行时库启动函数的主要功能为进行程序的初始化，对全局变量进行赋初值，加载用户程序的入口函数。

程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中，逻辑地址+基址

逻辑地址，线性地址，物理地址：   
逻辑地址（Logical Address） 是指由程式产生的和段相关的偏移地址部分；。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel保护模式下程式执行代码段限长内的偏移地址（假定代码段、数据段如果完全相同）。
线性地址（Linear Address）也叫虚拟地址(virtual address)是逻辑地址到物理地址变换之间的中间层。
物理地址（Physical Address） 是指出目前CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。

页表目录寄存器：每个进程都有自己的页表目录寄存器，

逻辑地址，先转到线性地址，线性地址，通过页表找到对应的物理地址；若没有启动页表，则线性地址直接就是物理地址。

shell是操作系统的外壳，为用户提供os的接口，.\a.out的将字符串发送到标准输出上，系统则通过gui显示的屏幕上；另外还可以重定向操作，将程序输出重定向到文件中一样。


linux文件描述符 0,1,2：stdin，stdout和stderr（默认分别是键盘、显示器、显示器），shell通过stdin文件描述符从键盘接收输入，并在键入时处理每个字符；stdout文件描述符引用shell的标准输出，在终端接口标准输出是终端显示器，shell的所有输出都定向到监视器。前台程序输出定向到标准输出，即显示器上，后台程序，定向到文件上。



#### linux最大分配几级页表：


地址：逻辑地址 --（段表）--> 线性地址 --（页表)--> 物理地址   
页表的启用，体现在线性地址上，若启用页表，要完成线性地址和物理地址的转化；逻辑地址到线性地址，就是取后48位即可。   



先看下系统的页表大小：
```bash
root@hw2:~# getconf PAGE_SIZE
4096
```

linux的页表分配是根据cpu来设计的，不同平台(cpu)分页不同,这里考虑x86平台:  

平台|linux页表|地址分配 |可表示大小
---|---|---|---
x86 |二级页表|10,10,12=32|4GB
x86_amd| 四级页表|9,9,9,9,12=48(线性地址)|256TB


intel 48线性地址划分：
![intel linear address](https://ask.qcloudimg.com/http-save/yehe-2966179/psg8p61gvr.png?imageView2/2/w/1620)
页表目录寄存器：每个进程都有自己的页表目录寄存器。

对应是：
单元|描述
---|---
页全局目录 | Page Global Directory
页上级目录 | Page Upper Directory
页中间目录 | Page Middle Directory
页表 | Page Table
页内偏移|Page Offset



linux把计算机分成独立层/依赖层两个层次，对于页面的映射和管理也是；linux从最初的2级页表，到3级页表(x86支持物理地址扩展)，再到4级页表(64cpu)。


总结来说：页表大小位4KB,所以页内地址需要12位，虚拟地址64位，需要8B,那一页最多存储4KB/8B=2^9,即一级页表占用9位，intel x86_64平台使用48位物理地址，剩余的48-32=9x4可以构成四级页表，48位物理地址可以表示多大的内存空间，2^48B=256TB,此外，x86系列是向后兼容的，为什么是4级页表？因为linux一路从2级页表、3级页表，再到当前的4级页表，满足当前需要，若未来那天不够用了，当然会扩展出更大的。

参考：
1. [Linux分页机制之概述--Linux内存管理(六)](https://cloud.tencent.com/developer/article/1373361)
2. [内核必须懂(七): Linux四级页表(x64)](https://cloud.tencent.com/developer/article/1421792)



---

逻辑地址和物理地址的转化：

分页、分段、

虚拟内存置换、页面置换算法：

linux文件

死锁、信号量

自旋锁和互斥锁一样是用来保护共享资源的，不同点在于资源被加锁时，互斥锁为让申请者睡眠，而自旋锁是通过循环检查的方式，所以自旋锁是一种较为低级的原始的锁，忙等，但避免了上下文的调度开销，因此对于只会阻塞很短时间的场景是有效的；整体上，耗费CPU时间较长，可能造成死锁，此外自旋锁不能递归调用。

[面试必备之深入理解自旋锁](https://zhuanlan.zhihu.com/p/40729293)



---
业务  
浏览器输入URL后，发生什么？

0. 解析URL，地址和参数   
1. 检查HSTS列表，决定使用HTTPS还是HTTP 
2. 浏览器通过DNS查找域名的IP地址
3. 依次查浏览器中缓存的DNS记录->系统中的DNS记录->请求域名解析服务器(递归和迭代两种方式)
4. ARP地址解析，解析到目标IP的MAC地址，或者局域网的路由器MAC
4. 浏览器与服务器建立TCP连接
5. TLS握手，使用HTTP协议请求发送数据（apached）
5. 发出Get命令，获取首页
6. 最后，释放TCP连接
7. 渲染首页所有内容

---

TLS:
基本过程
1. 客户端向服务器端索要并验证公钥
2. 双方协商生成"对话密钥"
3. 双方采用"对话密钥"进行加密通信
----
四次握手阶段（这里是单向认证过程）：  
hello消息阶段   
客户端发送ClientHello请求：
1. TLS版本
2. 客户端生成的伪随机数，用于生成对称密钥
3. 支持的加密算法
4. 支持的压缩算法

服务器响应ServerHello： 
1. 确认使用的TLS版本
2. 一个服务器生成的伪随机数，用于生成对称密钥
3. 确定使用的加密算法
4. 确定使用的压缩算法
5. 服务器证书（包含公钥）

证书校验部分   
客户端响应，在验证服务器证书之后：
1. 一个伪随机数，**用服务器公钥加密后传输**，防止被窃听
2. 编码改变通知，表示随后用双方协定的加密方法和密钥发送
3. 客户端握手结束，客户端的握手阶段结束，这一项同时也是前面发送的所有内容的hash值，用于供服务器校验    

    这时，客户端已经有生成对称密钥的三个随机数了，这里会把之前通信参数的hash值与其他相关信息生成一段数据，并用对称密钥加密，发送给服务器用于数据和握手验证，同时也会验证服务器发送来的验证消息，确定密钥和数据的正确性。

服务器响应：
1. 编码改变通知，表示之后用协定的加密算法和密钥
2. 服务器握手结束，表示服务器的握手阶段结束，这一项同时也是前面发送的所有内容的hash值，用来供客户端校验
（服务器用私钥解密加密的随机数，并生成对称密钥，计算之前通信参数的hash值，然后解密客户端发送的加密验证消息，验证数据和密钥的正确性，验证通过后，发送编码改变通知，同时用密钥加密生成的hash值发送到客户端，供其验证）    
    
    双方通过握手获得的是三个随机数和选择的加密算法，生成对话密钥，加密接下来的整个对话过程
握手过程使用明文通信，对话阶段加密。     

以上存在三个伪随机数又成为pre-master-key，主要是对称密钥生成需要pre master secret,如果知道pre master secret很容易确定密钥，并且TLS协议中的证书是静态的；所以这个pre master secret一般是个随机数，这里用三个伪随机数一同生成密钥是因为ssl不信任每个主机能产生完全随机的随机数，随机性就十分接近随机了。   



详细过程：
1. C->S,发送一个Client hello消息：消息中同时包括TLS版本，可用加密算法和压缩算法
2. S->C,返回一个Server hello消息：消息中包含了服务端的TLS版本，服务器选择的加密和压缩算法，服务器公开的证书，证书中包含了公钥;客户端会使用这个公钥加密接下来的握手过程，直到协商产生一个新的对称密钥
3. C->S,发送加密的伪随机数：客户端根据自己信任的CA列表，验证服务器的证书是否有效；若有效，客户端生成一串伪随机数，使用服务器的公钥加密它，发送到服务器上
4. S->C,发送生成的对称密钥：服务器用私钥解密客户端发来的伪随机数，并用该数生成一个对称加密的密钥
5. C->S,客户端发送一个Finished消息给服务器，和用对称密钥这次通讯的一个哈希值
6. S->C,服务端生成自己的哈希值，然后解密客户端发来的消息，检查这两个值是否对应，如果对应就向客户端发送Finished消息，并使用对称密钥加密此次消息
7. 接下来，双方通讯整个TLS会话都会使用对称密钥进行加密，传输应用层(http)内容


HTTPS (HTTP over TLS,即TCP上时TLS安全层，TLS上才是应用层HTTP)

