
#### 二叉树按层遍历  

1. 针对二叉树的宽度优先遍历。
2. 宽度优先遍历常使用队列结构。 
3. 面试中，该类题目常对换行有所要求，比如输出行号。

这里用队列+两个指针，last和nlast即可实现，按行控制输出。last为上一层最右节点，nlast为扫描的节点，当last==nlast时,就该换行了。 

```cpp
#include<iostream>
#include<queue>
using namespace std;
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
vector<vector<int> > printTree(TreeNode* root) {
	// write code here
	queue<TreeNode*>que;
	TreeNode*last1=root;
	TreeNode*last2=root;
	vector<vector<int> >res;
	vector<int> level;
	que.push(root);
	while(que.size()>0){
		TreeNode*tmp=que.front();
		level.push_back(tmp->val);
		que.pop();
		if(tmp->left!=NULL){
			que.push(tmp->left);
			last2=tmp->left;
		}
		if(tmp->right!=NULL){
			que.push(tmp->right);
			last2=tmp->right;
		}
		//换行
		if(last1==tmp){
			res.push_back(level);
			level.clear();
			last1=last2;
		}
	}
	return res;
}
int main(){
	TreeNode*h1=new TreeNode(1);
	TreeNode*h2=new TreeNode(2);
	TreeNode*h3=new TreeNode(3);
	TreeNode*h4=new TreeNode(4);
	TreeNode*h5=new TreeNode(5);
	h1->left=h2;h1->right=h3;h2->left=h4;h2->right=h5;
	vector<vector<int> >h=printTree(h1);
	for(int i=0;i<h.size();i++){
		for(int j=0;j<h[i].size();j++){
			cout<<h[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```

#### 二叉树序列化和反序列化 

1. 二叉树->字符串（序列化）
2. 字符串->二叉树（反序列化）
 
序列化方式：
1. 先序遍历NLR
2. LNR
3. LRN
4. 按层序列化  


给定一颗二叉树的头节点head,并已知二叉树节点值的类型为32位整型。请设计一种二叉树序列化和反序列化的方案，并用代码实现。 

对于空节点要特殊字符’#‘表示，用’!'表示整棵树结束，这样以上四种序列化都能唯一表示一棵树。
