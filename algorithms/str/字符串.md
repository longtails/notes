### 字符串

#### 案例零

如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A="12345",A的旋转词有"12345","23451","34512","45123"和"51234"。对于两个字符串A和B，请判断A和B是否互为旋转词。

给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。

测试样例：
"cdab",4,"abcd",4
返回：true


分析，可以用队列和栈来比较，一个从头入队，一个从尾入栈，每入一次，就比较队头和栈顶是否相等，若等，就弹出，继续比较，直到不等，接着扫描下一个元素；   
```cpp
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
//cdab abcd
bool chkRotation(string A, int lena, string B, int lenb) {
	stack<char>stk;
	queue<char>que;
	for(int i=0;i<lena;i++){
		que.push(A[i]);
		stk.push(B[lenb-i-1]);
		while(que.size()>0&&stk.size()>0){
			char q=que.front();
			char p=stk.top();
			if(p==q){
				que.pop();stk.pop();
			}else{
				break;
			}
		}
	}
	return stk.size()==0&&que.size()==0;
}
int main(){
	cout<<chkRotation("cdbb",4,"abcd",4)<<endl;
	return 0;
}
```
最优解时间复杂度O(N)：   
1. 判断str1和str2是否相等   
2. 如果长度相等，生成str1+str1的大字符串
3. 用KMP算法判断大字符串中是否含有str2   
举例说明：str1=1234,str1+str1=12341234,如果str2长度和str1相等，且str2是str1+str1的子串，则str2一定是str1的旋转词。


#### 案例零一

给定一个字符串str,请在单词间做逆序调整。  
举例："ping loves dog"逆序成"dog loves pig" 

这种题，代表一种，不考察什么高深算法，仅仅考察代码实现能力。   
分析：用栈，遇到空白，就清空栈，清出的元素正好单词逆序，并记录下来，最后再对记录的字符串用栈逆序一次即可。  

#### 案例零二

给定一个字符串str,和一个整数i，i代表str中的位置，将str[0,..i]移到右侧,str[i+1,..N-1]移到左侧,要求时间复杂度为O(N),额外空间复杂度为O(1)。

举例： “ABCDE" ->"DEABC"

方法：对分别对[0,i]和[i+1,n)逆序操作，最后对整体逆序，就交换了两边。  

与字符交换相关的题目，大部分是活用局部逆序函数组合的过程。 

#### 案例零三

给定一个字符串类型数组strs，请找到一种拼接顺序，使得所有字符串拼接起来组成的大写字符串是所有可能性中字典顺序最小的，并返回这个大字符串。  

举例： ["abc","de"]拼接成“abcde"，“deabc","abcde" ,这里"abcde"字典顺序最小。  

方法：通过字符串排序即可，比较大小是拼接两个字符串st1+str2和str2+str1比较字典顺序，最后将排序的结果拼接即可。时间复杂度O(N*logN)。直接比较两个字符串是错的，比如"b"<"ba",那结果是"bba",实际上应该是"bab"。



