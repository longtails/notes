
### 排列组合

概率组合题目分类：
1. 以高中数学为基础的古典概率计算方法
2. 斐波那契数和卡特兰数
3. 以选择题居多 

$$
C_{n}^m=\frac{n!}{m!*(n-m)!}=\frac{n*(n-1)*...*(n-m+1)}{m*(m-1)*...*1}
$$
$$
A_n^m=\frac{n!}{(n-m)!}=n*(n-1)*...*(n-m+1)
$$
#### 案例一

在6x9的方格中，以左上角为起点，右下角为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法。  

总共13步，其中5步向下，8步向右：
$$
C_{13}^5  = C_{13}^8=\frac{13*12*11*10*9}{5*4*3*2*1}
$$



#### 案例二

ABCDEFG七人站队，要求A必须站在B的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求A必须在B的左边，并且一定要相邻，请问一共有多少种排法？ 

分析，七个人全排列，7!,有一半的情况A在B的左边，所以7!/2=2520;AB在一起，则把他们当一个人，现在六个人全排列，6！=720。

高中数学插空法:
$$
A_5^5*(C_6^2+C_6^1)=2520
$$
$$
A_5^5*C_6^1=720
$$
```cpp
#include<iostream>
using namespace std;
int C(int x,int y){
	if(x<y)return 0;
	int n=1;
	//x x-1 ... x-y+1
	for(int i=x-y+1;i<=x;i++){
		n*=i;
	}
	int m=1;
	for(int i=1;i<=y;i++){
		m*=i;
	}
	return n/m;
}
int A(int x,int y){
	int n=1;
	for(int i=x-y+1;i<=x;i++){
		n*=i;
	}
	return n;
}
void  getWays(int n, int a, int b) {
	cout<<A(n-2,n-2)*(C(n-1,2)+C(n-1,1))<<endl;
	cout<<A(n-2,n-2)*C(n-1,1)<<endl;
}
int main(){
	getWays(7,1,2);
}
```


#### 案例三

六个人排成一排，要求甲与乙不相邻，并且甲与丙不相邻的排法数是多少？

先对A之外的人全排列（A,D,E,F），然后BC,除A周外的空上插入，有两种，一是分开插，一是最为一块，插入。
$$A_4^4*(A_3^2+C_3^1*A_2^2)=288$$
所以共有288种。
```cpp
#include<iostream>
using namespace std;
int C(int x,int y){
	int tmp=1;
	for(int i=x-y+1;i<=x;i++){
		tmp*=i;
	}
	for(int i=1;i<=y;i++){
		tmp/=i;
	}
	return tmp;
}
int AA(int x,int y){
	int tmp=1;
	for(int i=(x-y+1);i<=x;i++){
		tmp*=i;
	}
	return tmp;
}
int getWays(int n, int A, int b, int c) {
	return AA(n-2,n-2)*(AA(n-3,2)+C(n-3,1)*AA(2,2));
}
int main(){
	cout<<getWays(6,1,2,3)<<endl;
	return 0;
}
```
 
#### 案例四

10颗相同的糖果，分给3个人，每人至少一颗，问有多少种分法。

隔板法，10颗糖，中间9个隔，插入两个，分成三份，故有
$$ C_9^2 $$
种分法。

```cpp
class Distribution {
public:
    int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
	    	tmp*=i;
	    }
	    for(int i=1;i<=y;i++){
	    	tmp/=i;
	    }
	    return tmp;
    }
    int getWays(int n, int m) {
        // write code here
        return C(n-1,m-1);
    }
};
```

#### 案例五

10个不同的球放入3个不同的桶里有多少种方法。

**注意，这里不同的球**，每个球最终要放入一个桶里，故有3种选择，那10个球就有
$$
3^{10}
$$
若，每个桶都至少一个球呢，那先选3个球放入到桶中，C(10,3)之后再3^7，最后C(10,3)*3^7。 

#### 案例六

有10颗糖，如果每天至少吃一颗，吃完为止，问有多少种不同的吃法？

从1天吃完到10天只吃完，所有对各种情况插板求解，最后累加。   
二项式定理：
$$
1+C_9^1+C_9^2+C_9^3+...+C_9^9=(1+1)^9=2^9=512
$$



#### 案例七

假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法的。

做括号数量为n，右括号数量为n，总排列数为C(2n,n),不合法的排列一定是出现了右括号比做括号多一个的前缀。现在把(记为1，)记为-1，

举例：   
1. ```())(()```,即[1,-1,-1,1,1,-1,-1]其中前三个-1的数量比1多,则一定不合法；   
2. 对前三个进行变换，将1变为-1，将-1变为1，现在为[-1,1,1,1,1,-1]即```())(()```，总体来看，经过如上的变换方式将得到n+1个1和n-1个-1组成的排列；  
3. 可以证明，每一个非法的排列通过如上的变换方式，可以得到n+1个1和n-1个-1所组成的排列,同样也可以还原(**即,这是一个现象，只要不合法就一定对应一个n+1个1和n-1个-1,所以只需要确定有多少种上述n+1个1和n-1个-1的情况，即可求出不合法数**)；   
4. 所以不合法的排列数=n+1个1和n-1个-1组成的排列数=C(2n,n+1)=C(2n,n-1)。     

5. 所以合法的排列数为 C(2n,n)-C(2n,n+1)=1/(n+1) *C(2n,n),即卡特兰数公式。

 
**卡特兰数重要公式之一**：
$$
C_{2n}^n-C_{2n}^{n+1}=\frac{1}{n+1}*C_{2n}^n
$$


eg:假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法。

给定一个整数n，请返回所求的合法排列数。保证结果在int范围内。

测试样例：
1   
返回：1
```cpp
class Parenthesis {
public:
     int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
	    	tmp*=i;
	    }
	    for(int i=1;i<=y;i++){
	    	tmp/=i;
	    }
	    return tmp;
    }
    int countLegalWays(int n) {
        return C(2*n,n)/(n+1);
    }
};
```


#### 案例八

n个数进出栈的顺序有多少种？假设栈的容量无限大。再补充一个问题，2n个人排队买票，n个人拿5块钱，n个人拿10块钱，票价是5块钱1张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。

把进栈当成左括号，把出栈当成右括号。  
把5块钱当成左括号，10块钱当成有括号。  
计算同上，卡特兰数。  

e.g.:进出栈   
n个数进出栈的顺序有多少种？假设栈的容量无限大。

给定一个整数n，请返回所求的进出栈顺序个数。保证结果在int范围内。

测试样例：
1   
返回：1

```cpp
class Stack {
public:
     int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
	    	tmp*=i;
	    }
	    for(int i=1;i<=y;i++){
	    	tmp/=i;
	    }
	    return tmp;
    }
    int countWays(int n) {
        // write code here
        return C(2*n,n)/(n+1);
    }
};
```

e.g.: 排队买票问题   
2n个人排队买票，n个人拿5块钱，n个人拿10块钱，票价是5块钱1张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。

给定一个整数n，请返回所求的排队方案个数。保证结果在int范围内。

测试样例：
1   
返回：1

```cpp
class BuyTickets {
public:
     int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
	    	tmp*=i;
	    }
	    for(int i=1;i<=y;i++){
	    	tmp/=i;
	    }
	    return tmp;
    }
    int countWays(int n) {
        return C(2*n,n)/(n+1);
    }
};
```
#### 案例九

求n个无差别的节点构成的二叉树有多少种不同的结构？

假设n个无差别的节点构成不同的结构数为f(n),  
f(0)表示空树，所以规定种数为1;  
以1节点为头时，结构数为1\*f(n-1);    
以2节点为头时，结构数为f(1)\*f(n-2);    
以3节点为头时，结构数为f(2)\*f(n-3);   
以4节点为头时，结构数为f(3)\*f(n-4);   
...   
以n-1节点为头时，结构数为f(1)\*f(n-1);   
以n节点为头时，结构数为f(0)\*f(n)。   

**卡特兰数重要公式2**：  
即，f(0)=1,f(1)=1,f(2)=2,f)3)=5时，   
$$
f(n)=f(0)*f(n-1)+f(1)*f(n-2)+f(3)*f(n-4)+...+...+f(n-1)*f(0)
$$
$$
f(n)=\frac{1}{n+1}*C_{2n}^n
$$

```cpp
class TreeCount {
public:
     int C(int x,int y){
    	int tmp=1;
    	for(int i=x-y+1;i<=x;i++){
	    	tmp*=i;
	    }
	    for(int i=1;i<=y;i++){
	    	tmp/=i;
	    }
	    return tmp;
    }
    int countWays(int n) {
        return C(2*n,n)/(n+1);
    }
};
```

#### 案例十

12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？

这时一个隐藏很深的卡特兰数问题，假设0：第一排，1:第二排,身高排序：[0,0,0,0,1,1,0,1,0,1,1,1]，当前前缀1比0个数多的话，说明必然会出现不合法的情况，即第二排一定有个高在前排，个低在后排。->问题转变为任意前缀不能出现1比0多的情况，所以与案例七一样，依然是卡特兰数问题。



#### 案例十一

有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少中装法？


对于n封信，按照题目要求的装法记为f(n),假设第n封信放入了第i个信封：  
第一种情况：第i封信也放入了第n个信封中，后续为f(n-2);  
第二中情况：第i封信没放入了第n个信封中，后续为f(n-1);  
其中i有n-1种选法，所以f(n)=(n-1)*(f(n-1)+f(n-2))。  

```cpp
//f(n)=(n-1)(f(n-1)+f(n-2))
//f2=1
//f3=2
//f4=3*(f3+f2)
int countWays(int n) {
	long  a=1,b=2;
    if(n==1)return 0;
	if(n==2)return 1;
	if(n==3)return 2;
	for(int i=4;i<=n;i++){
        //(i-1)*(a+b)超过int了，所以a,b要用long
		long  tmp=((i-1)*(a+b))%1000000007;
        //2147483647
        //1000000007
		a=b;b=tmp;
	}
	return b;
}
```